# Go 架构实践 - 微服务(微服务概览与治理)学习笔记

## 微服务概览 
技术的迭代总是在不断的遇到问题和解决问题，在具体学习微服务前，需要了解下为什么会有这个概念、它是如何产生的，那就不得不提早期应用的单体架构
### 单体架构
早期应用大多是单体架构，后端服务、前端页面都在写在同一个系统里，部署非常方便，直接打包部署即可。

但这又带来了的新的问题：
- **开发人员需要掌握的较多**。当然早期vue什么的都还未流行，那会大多使用`ajax`,`jquery`，大家都是后端、前端一起开发、写单元测试
- **版本控制沟通成本大**。大家都在一个组内，系统就一个，提交、拉取、推送代码时要小心，最好是不要冲突。如果出现冲突了，解决该问题可能还需要别的开发来协助，毕竟一个系统，大家又分工合作，一般都是对自己负责的业务熟悉。因此才需要别的开发协助，别把同事的代码给勿删了。
- **后期维护难**。业务越复杂，代码量越大，原有系统代码增减越频繁，导致代码真的是一坨又一坨，没有谁一开始就能设计好完美架构，能适配未来所有场景。不然，也不会有此文章了。
- **部署容易，运维难**。因为是一个系统，只要代码有丁点儿改动，整个项目就要重新编译、打包、发镜像、发不同环境(测试、灰度、生产等)。笔者在JD时，负责的一个财务系统非常复杂，是三个大系统合并后的，光编译+打包就得25分左右，快的时候18分（当时使用JDos发布），所以经常会有旁边同事说：”帮我发下XX项目，我去楼下抽根烟“......
- **测试不流畅，严重依赖全局**。我们组专门有配备的测试哥哥，我是应届生，刚进去会轮值测试岗，跟着这个测试哥哥写过测试用例。整个测试用例，根据功能(或者说业务)来划分目录，然后再对应某个功能细分接口测试，写的非常详细，并且根据优先级来决定先测哪些系统。我仍记得17年那个冬天，因为一个开发小哥哥的项目有问题，导致后面的系统根本没法测试，而他的项目也没完成，也没法测试，只能等他解决了才能做后续步骤。测试环境早就搭好了，就等项目发布测试了，结果却来这一出，我们就这样干等了一下午，直到晚上快吃饭他才解决了。但是deadline是不变的，于是我们几个测试又加班加点开始一个一个测试，测出来问题就提BUG，催他们解决。这样的场景并不是只有这一次，说出来都是泪......
- **生产环境出问题影响大**。项目正常运行还好，但是一出事就是事故，本来A服务正常，却因为B服务挂掉，导致整个项目都挂，所以项目必须降级(手动切回老版本)，然后再解决问题，解决了再重新发布到新版本。

正是因为有上述问题，所谓的敏捷开发和部署(当时内部开始推广)成了空中楼阁，很多次会议都耗时、耗心，甚至影响到了组内团结。
### 微服务起源
后来leader也明白此事的严重性，所以在此后开发一个新项目的时候，全面采用了SOA架构，即面向服务的架构。但是本质上，项目还是一个单体应用，并没有拆分为一个个单体服务，部署的时候也是整个系统部署，并非分布式部署。

不过这已经在进步了，那时基本上是通过XMl([标准通用置标语言](https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80/10471466?fromtitle=%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80&fromid=6805073))来描述接口，在`.xml`文件中，定义了业务接口、provider、consumer等。(笔者之前是Java开发)

但本质上并没有解决上述问题，由于系统庞大，所以一个系统的`.xml`管理至关重要。当时我负责的财务系统本来是三大系统合并的，因此`.xml`文件繁多也复杂，在整理后，会有诸如此类的命名：`finance-XXX-provider.xml`、`finance-XXX-consumer.xml`、`workflow-XXX-provide.xml`、`workflow-XXX-consumer.xml`、`worker-XXX-provide.xml`、`worker-XXX-consumer.xml`等等...... 

当时流行一句话："要想搞定XX系统，看xml配置就行"。我不知道是谁提出来的，我真想送他一块砖。我所负责的财务系统，密密麻麻的`.xml`配置，有的有注释，有的没有，关键是不止这样一个文件，是很多，让你绝望的那种多......

所以，对于一个刚毕业大学生，除了加班还剩什么？头发吗？
### 微服务定义
后来微服务概念大行其道，到现在的云原生，我们先关注微服务，毕竟微服务是云原生的一个子集。
#### 定义
**微服务**围绕业务功能构建的，服务关注**单一业务**，服务间采用**轻量级的通信机制**，可以**全自动独立部署**，可以使用**不同的编程语言和数据存储技术**。

微服务架构通过业务**拆分**实现**服务组件化**，通过**组件组合**快速开发系统，**业务单一的服务组件又可以独立部署**，使得整个系统变得清晰灵活。

#### 特性
- 原子服务
- 独立进程
- 隔离部署
- 去中心化服务治理

### 微服务不足

Fred Brooks 在30年前写道：
> there are no silver bullets

但凡事有利就有弊，微服务也不是万能的。
- 微服务应用是分布式系统，由此会带来固有的复杂性。开发者不得不使用 RPC 或者消息传递，来实现进程间通信；此外，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题。
- 分区的数据库架构，同时更新多个业务主体的事务很普遍。这种事务对于单体式应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务所使用的不同的数据库，从而对开发者提出了更高的要求和挑战。
- 测试一个基于微服务架构的应用也是很复杂的任务。
- 服务模块间的依赖，应用的升级有可能会波及多个服务模块的修改。
- 基础设施的建设、复杂度高，对运维基础设施的挑战比较大。
- 服务拆分粒度不好把控，需要有多年实战经验，整体把控

### 组件服务化
传统实现组件的方式是通过库(library)，库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署。 

通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程。

我们用 Go 实施一个微服务：
- kit：一个微服务的基础库(框架)，如go-kit，go-micro，dubbo-go
- service：业务代码 + kit 依赖 + 第三方依赖组成的
业务微服务
- rpc + message queue：轻量级通讯，服务与服务间通信

本质上等同于，多个微服务组合(compose)完成了一个完整的用户场景(usecase)

单体架构 -> 微服务架构

![](https://pic4.zhimg.com/80/v2-03547986b5765274bbe63e1bd387bef3_720w.jpg)

### 按业务组织服务
按业务能力组织服务的意思是服务提供的能力和业务功能对应，比如：订单服务和数据访问服务，前者反应了真实的订单相关业务，后者是一种技术抽象服务不反应真实的业务。

所以按微服务架构理念来划分服务时，是不应该存在数据访问服务这样一个服务的。

事实上传统应用设计架构的分层结构正反应了不同角色的沟通结构，

![](../Week01/image/架构-职责-团队.png)

所以若要按微服务的方式来构建应用，也需要对应调整团队的组织架构。每个服务背后的小团队的组织是跨功能的，包含实现业务所需的全面的技能。
![]()

**示例模式：**

> 大前端(移动/Web) =》 网关接入 =》业务服务 =》平台服务 =》基础设施(PaaS/Saas)开发团队对软件在生产环境的运行负全部责任！


### 去中心化
每个服务面临的业务场景不同，可以针对性的选择合适的技术解决方案。但也需要避免过度多样化，结合团队实际情况来选择取舍，要是每个服务都用不同的语言的技术栈来实现，想想维护成本真够高的。
#### 技术去中心化
由于服务都拆分开，可单一部署维护，因此每个微服务的技术栈不再是强制唯一的，可以使用其他编程语言来实现，只要保证服务可用且有质量。

- 一般的，对于一个新项目，大都使用同一个语言贯穿整个项目周期
- 对于旧项目重构，比如改用其他语言重写，那么微服务的技术去中心化优势便提现的淋漓尽致。可以直接重构，然后部署、测试、一个一个服务逐渐上生产环境，运行稳定后就可以将旧服务切到新服务上
#### 数据去中心化
每个微服务独享自身的数据存储(redis\mysql等)，不像传统应用共享一个缓存和数据库，这样有利于服务的独立性，隔离相关干扰。

服务与服务之间通过rpc通信来进行数据交互。
#### 治理去中心化
一般的，服务治理通常是在API网关来统一进行服务治理，网关作为代理处理外部服务的请求，并提供服务注册与发现、负载均衡、日志监控、容错等功能。

然而，这种方案也存在不足，比如**网关的单点故障**、**系统架构变得异常庞大**；从功能来看，API 网关主要是面向用户，也就是说它可以解决从用户到各个后端服务的流量问题，至于其他问题，它可能就无能为力了。

但实际上，需要的是一个完整的贯穿整个请求周期的方案，或者至少是一些能够与 API 网关互补的方案和工具。

Service Mesh，又称服务网格，可以很好的解决上述问题。具体使用待补充......

### 基础设施自动化
无自动化不微服务，自动化包括测试和部署。单一进程的传统应用被拆分为一系列的多进程服务后，意味着开发、调试、测试、监控和部署复杂度都会相应增大，必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加。

- CICD：Gitlab + Gitlab Hooks + k8s /Jenkins + k8s
- Testing：测试环境、单元测试、API自动化测试（如[yapi](https://yapi.baidu.com/doc/documents/index.html)）
- 在线运行时：k8s，以及一系列 Prometheus(监控)、ELK(日志采集、分析)、Conrtol Panle

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1606038189931&di=ee12bbdfeaa0919f3ab8e5a631d74394&imgtype=0&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20200508%2Ff60f0db520904d88a057be24a3915fb1.jpeg)
### 可用性 & 兼容性设计
著名的 `Design For Failure` 思想，微服务架构采用粗粒度的进程间通信，引入了额外的复杂性和需要处理的新问题，如网络延迟、消息格式、负载均衡和容错，忽略其中任何一点都属于对“分布式计算的误解”。
- 隔离
- 超时控制
- 负载保护
- 限流
- 降级
- 重试
- 负载均衡
一旦采用了微服务架构模式，那么在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，**时刻谨记保持服务契约(接口)的兼容性**。

所以要深刻理解这样一个理念：
> Be conservative in what you send, be liberal in what you accept.

即**发送时要保守，接收时要开放**。按照`伯斯塔尔法则`的思想来设计和实现服务时，发送的数据要更保守，意味着**最小化**的传送**必要**的信息，接收时更开放意味着要**最大限度的容忍冗余数据**，保证兼容性。

## 微服务设计
主要记录如何从SOA架构一步步进化到微服务架构，并成功在线上运行。

### API Gateway 演进

#### SOA架构下的问题 1.0版本
我们进行了 SOA 服务化的架构演进，按照垂直功能进行了拆分，对外暴露了一批微服务:

![](../Week01/image/SOA%20架构-微服务演进1.png)


但是因为缺乏统一的出口面临了不少困难：
- 客户端到微服务直接通信，强耦合：
  - 浏览器还好，但是移动端面临诸多问题，比如用户始终不愿意将app升级，依然使用旧版本，意味着服务要有很强的兼容性，不能顾此失彼。
    
- 移动端需要多次请求，客户端聚合数据，工作量巨
大，延迟高。
  - 移动端团队与其他业务方沟通成本大。聚合一个合格的数据，可能需要调用不同的接口，这就意味着需要和不同团队联调接口，接口改动了，移动端也得跟着改，并且接口规范不一定统一，增加了心智负担，协调成本大，工作量也大。
  - 客户端团队接口维护困难。一个页面可能需要调很多接口才能返回合格数据，导致多次请求，延迟高，有些接口可能还会失败，无法降级。
- 协议不利于统一，各个部门间有差异，需要
端来兼容。
- 面向“端”的API适配，耦合到了内部服务。
  - 为了适应不同型号的操作系统，如IOS 5.X\6.X，安卓不同版本，需要在内部服务中适配这些终端，字段需求不一致，对应的服务也要进行适配，保证用户使用app流畅。
- 多终端兼容逻辑复杂，每个服务都需要处理。
- 统一逻辑无法收敛，比如安全认证、限流。

为了留存用户，提升流量，应用发版就要迭代较快，尤其是app端，因此每一次发版既要保证质量还要讲究效率。所以，一些较复杂的工作可以交给服务端处理，如数据的组装聚合，在这种场景下，就需要引入API Gateway，提供友好的面向业务场景的API。

#### 初步引入BFF 2.0版本
我们新增了一个 `app-interface` 用于统一的协议出口，在服务内进行大量的 dataset join，按照业务场景来设计粗粒度的 API：


![](../Week01/image/SOA%20架构-微服务演进2.jpg)

这给后续服务的演进来的很多优势：
- 轻量交互：协议精简、聚合。
- 差异服务：数据裁剪以及聚合、针对终端定制化API。
  - 针对不同网络情况，比如3g,4g,5g，不同终端，差异性定制化API
- 动态升级：原有系统兼容升级，更新服务而非协议。
  - 业务服务可以随时迭代升级，只要保证和BFF层的接口兼容即可
- 沟通效率提升：协作模式演进为移动业务对接网关小组，其他业务组直接和网关组对接即可。不再是移动组直接对接多个业务组了

`BFF`(面向前端场景的后端服务)可以认为是一种适配服务，将后端的微服务进行适配(主要包括聚合裁剪和格式适配等逻辑)，向无线端设备暴露友好和统一的 API，方便无线设备接入访问后端服务
#### 优化BFF 3.0版本
API Interface 1.0 最致命的一个问题是整个 `app-interface` 属于`single point of failure`(单点故障)，严重代码缺陷或者流量洪峰可能引发集群宕机，即如果BFF层宕机，那么和其有依赖的业务服务就全炸了。

因此，为了解决以上问题，针对不同业务领域，BFF层创建了对应的`xxx-interface`，架构如下：

![](../Week01/image/SOA%20架构-微服务演进3.jpg)

除此之外，单个模块也会导致后续业务集成复杂度高，根据康威法则，单块的无线BFF和多团队之间就出现不匹配问题，团队之间沟通协调成本高，交付效率低下。

但是BFF2.0架构仍存在一个问题：
- 很多**跨横切面**逻辑，比如安全认证，日志监控，限流熔断等。随着时间的推移，代码变得越来越复杂，技术债越堆越多。

这个问题尤其是在安全认证，日志监控，限流熔断这些基础库要迭代升级的时候，每次更新版本，都要将BFF层中的服务全部跟着升级一遍，如果服务过多，这是一个不小的工作量。

补充：[AOP切面编程](../Week01/doc/AOP切面编程.md)

#### 新增API Gateway 4.0版本

跨横切面(Cross-Cutting Concerns)的功能，需要协调更新框架升级发版(路由、认证、限流、安
全)，因此全部上沉，引入了 `API Gateway`，把业务集成度高的 BFF 层和通用功能服务层 `API Gateway` 进行了分层处理。
 
![](../Week01/image/SOA%20架构-微服务演进4.jpg)

在新的架构中，网关承担了重要的角色，它是**解耦拆分**和**后续升级迁移**的利器。在网关的配合下，单块 BFF 实现了解耦拆分，各业务线团队可以独立开发和交付各自的微服务，研发效率大大提升。

另外，把跨横切面逻辑从 BFF 剥离到网关上去以后，BFF 的开发人员可以更加**专注业务逻辑交付**，实现了架构上的关注分离(Separation of Concerns)。

我们业务流量实际为：
> 移动端 -> `API Gateway` -> `BFF` -> `Mirco Service`，在FE Web业务中，`BFF` 可以是 nodejs 来做服务端渲染(SSR，Server-Side Rendering)，注意这里忽略了上游的 `CDN`、4/7层负载均衡(`ELB`)。

补充知识：[四层、七层负载均衡的区别](https://mp.weixin.qq.com/s/9POrwe3jrE1kChps6r-osQ?)